package java1;
/**
 * java泛型学习
 * 优势：泛型在安全性跟表述性方面有优势
 * 官方理解：
 * 使用泛型比使用需要在客户端代码中进行转换的类型来的更安全，也更容易.
 * 设计新类型时，要确保他们不需要这种转换就可以使用.新用户使用变得更加轻松，又不会破坏现有的客户端
 * 个人理解
 * 1. 安全：明确规定使用的类型了
 * 使用别的类型编译不通过
 * 2.表述：客户端很明确表达的意思了，
 * List searchUser();
 * List<User> search User
 * @author admin
 *
 */
public class JavaGenerics {
/**
 * 专业术语： 
 * 
 * 参数化的类型： List<String>
 * 实际类型参数：String
 * 泛型：List<E>
 * 形式类型参数：E
 * 无限制通配符类型：List<?>
 * 原生态类型:List
 * 有限制类型参数： <E extends Number>
 * 递归类型限制：<T extends Comparable<T>>
 * 有限制通配符类型：List<? extends Number>
 * 泛型方法: static <E> List<E> asList(E[] a)
 * 类型令牌： String.class
 */
	
/**
 * 泛型的使用：
 * 一：？
*？表示类型通配符，即具体传什么参数类型，在List定义时不用考虑。
*
*二：<T>
*这里的<>表示泛型，T表示泛型中装载的类型为T类型，等到需要的时候，我们可以具体这个T。我们在使用动态数组实现ArrayList的时候，
*如果希望这个ArrayList不仅仅支持一个类型的话，我们可以给这个ArrayList定义泛型，泛型中存放的是T类型。
*在实际创建出这个ArrayList对象时，我们可以指定泛型中的具体类型。
*
*三：<? extends T>
*类型上界。
*表示的是此处我们传入的类型必须是T类型本身或其子类。如果这里的T为Number的话，那么我们只能传入Number本身或其子类，比如Integer,Floart等基本数据类型的包装类。
*
 *四：<? super T>
 *    类型下界。
 *    表示的是此处我们传入的类型必须是T类型本身或其超类。如果这里的T为Integer的话，那么我们只能传入Integer本身或其超类，比如Number类。
*     
* 五：泛型静态工厂方法
 */
	
	/**
	 * 第一点：泛型使用列表优先于数组
	 * 不是很明白后续继续思考
	 */
	/**
	 * 第二点：泛型静态工厂方法
	 * 
	 */
	/**
	 * 第三点：优先考虑类型安全的异构容器
	 * 具体：等待重新复习在研究
	 */
}
